1. Structures allow us to store groups of different but usually related variables together, which allows for much better organization and ease of access when calling said variables. The variables can be both array and types. When variables are grouped into a structure, the structure is treated as one entity but individual variables within can be called and used. This allows us to modify everything contained in the structure at once. Taking this workshop as an example, I put variables related to the player’s info into one structure with a line such as ‘struct PlayerInfo player = { }’, and variables relevant to the game with ‘struct gameInfo game = { }’. I then initialized everything within the structure with one line of code. Additionally, if I wish to call a variable that is related to the player but do not remember the name, simply typing in ‘player.’ would display a list of the contained variables. This process made everything much more organized, since it is much easier to remember what the purpose of each variable was. Furthermore, the workshop no longer had as many disorganized variables initialized after the main function, as some were neatly stored in structures.  

2.The first major change that I would make is to add an additional structure to keep track of every game’s result by adding an array to record that player’s symbol as well as their endgame score. However, since space is limited, there will have to be a hierarchy of results like a high score system where only the top scores (i.e., the top 5) are kept. This would lead into the second major change. Each new score would be compared to the top scores starting with the lowest of the top scores until a suitable place is found. Once the correct position is found, everything under the new score would be shifted one place up, with the lowest score removed. For example if the current array ‘score [5] = {9 , 7, 5, 3, 2 }’ and a new game with a score of 6 is achieved, score 6 would be compared to 2, then 3 then 5 and 7. Score 5 and 3 would be shifted, and score 2 would be removed, while score 6 would be inserted into the original place of 5.

3. The part of the workshop that I spent the most time working on would be step #7 in part two as it required the most lines of code to function and the concept to keep track of each move was somewhat confusing.  To overcome this difficulty, I set up an array of the bombs, treasures, and move history in an excel spreadsheet with the index numbering at the top. This setup gave me a good visualization of what was supposed to happen when the player moves. Each user inputted move would refer to the array index and switch the element of that index to a 1.  This would server two functions. The first is to trigger the check for a bomb and treasure depending on the player’s setup configuration. The second function would be used to keep track of the player’s move history and display the appropriate messages. By adding a visual aid, it allowed my mind to understand the concept of the game, and everything afterwards was relatively easy.  
